################################
# EvoMan FrameWork - V1.0 2016 #
# Author: Karine Miras         #
# karine.smiras@gmail.com      #
################################

import sys
import numpy
import pygame
from pygame.locals import *
import tmx

from struct import *
from player import *


# Main class.
class Game(object):
   

        # Simulation parameters.
	def __init__(self,  
                     multiplemode="no",           # yes or no
                     enemies=[1],                 # array with 1 to 8 itens, values from 1 to 8
                     loadplayer="yes",            # yes or no
                     loadenemy="yes",             # yes or no
                     level=1,                     # from 1 to 3
                     playermode="human",          # ai or human
                     enemymode="static",          # ai or static 
                     speed="normal",              # normal or fastest
                     inputs_coded="no",           # yes or no
                     randomini="no",              # yes or no
                     sound="on",                  # on or off
                     contact_hurt="player",       # player or enemy
                     logs="on",                   # on or off
                     savelogs="yes",              # yes or no
                     clock_prec="low"    ):       # low or medium

            

        	self.multiplemode = multiplemode
        	self.enemies = enemies
                self.enemyn = enemies[0] # initial current enemy
                self.loadplayer = loadplayer
                self.loadenemy = loadenemy
        	self.level = level
                self.playermode = playermode
                self.enemymode = enemymode
                self.speed = speed
                self.inputs_coded = inputs_coded
                self.randomini = randomini
                self.sound = sound
                self.contact_hurt = contact_hurt
                self.logs = logs
                self.savelogs = savelogs
                self.clock_prec = clock_prec


                # Initializes log file.
                if self.logs  == "on" and self.savelogs == "yes":
                    file_aux  = open('evomanlogs.txt','w') 
                    file_aux.close()

 
		pygame.init() # Initializes pygame library.
                self.print_logs("WARNING: Pygame initialized for simulation.")

                if self.sound == "on" and self.playermode == "human":
		    pygame.mixer.init() # Initializes sound library for playing mode.
                    self.print_logs("WARNING: sound has been turned on.")

                if self.playermode == "human":
		    pygame.joystick.init() # Initializes joystick library and gets joysticks connected for playing mode.
		    self.joy =  pygame.joystick.get_count() 

		self.clock = pygame.time.Clock() # Initializes game clock resource.


		# Generates screen.
		if self.playermode == 'human': # playing mode in fullscreen.
			flags =  DOUBLEBUF  |  FULLSCREEN
		else:
			flags =  DOUBLEBUF     

		self.screen = pygame.display.set_mode((736, 512), flags)

		self.screen.set_alpha(None) # Disables uneeded alpha.
		pygame.event.set_allowed([QUIT, KEYDOWN, KEYUP]) # Enables only needed events.


        def update_parameter(self, name, value): # method for user to update simulation parameters
 
            if type(value) is str:
                exec('self.'+name +"= '"+ value+"'")
            if type(value) is int or type(value) is list:
                exec('self.'+name +"= "+ str(value))

            self.print_logs("PARAMETER CHANGE: "+name+" = "+str(value))
 


        def print_logs(self, msg): 
            if self.logs == "on":  
                print '\n'+msg # prints log messages to screen

                if self.savelogs == "yes": # prints log messages to file
                    file_aux  = open('evomanlogs.txt','a')
                    file_aux.write('\n\n'+msg) 
                    file_aux.close()



        def statetolog(self): # writes all variables related to game state into log

      
            self.print_logs("########## Simulation state ###########")
            self.print_logs("multiple mode : "+self.multiplemode)
            en = ''
            for e in self.enemies:
                en += ' '+str(e)
            self.print_logs("enemies:"+ en) 
            self.print_logs("current enemy: " +str(self.enemyn))
            self.print_logs("load player: " +self.loadplayer)
            self.print_logs("load enemy: " +self.loadenemy)
            self.print_logs("level: " +str(self.level))
            self.print_logs("player mode: " +self.playermode)
            self.print_logs("enemy mode: "  +self.enemymode)
            self.print_logs("speed: " +self.speed)
            self.print_logs("inputs coded: "  +self.inputs_coded)
            self.print_logs("random ini: "  +self.randomini)
            self.print_logs("sound: "  +self.sound)
            self.print_logs("contact hurt: "  +self.contact_hurt)
            self.print_logs("logs: "+self.logs)
            self.print_logs("savelogs: "+self.savelogs)
            self.print_logs("clock prec: "+ self.clock_prec)
            if hasattr(self, 'enemy'):
                self.print_logs("sensors: "+ str(len(self.player.sensors)))
            self.print_logs("##############################")


        def run_single(self,enemyn): # Runs game for a single enemy.



                # Validates parameters.

                if self.multiplemode == "yes" and len(self.enemies) < 2:
                    self.print_logs("ERROR: enemies list must contain more than one enemy for multiple mode.") 
                    sys.exit(0)    

                # Checks parameters.

                if self.multiplemode == "no" and len(self.enemies) > 1:
                    self.print_logs("WARNING: there is more than one enemy in the list although the mode is not multiple.") 

                if self.level < 1 or self.level > 3:
                    self.print_logs("WARNING: level chosen is out of recommended (tested).") 


                self.enemyn = enemyn # sets the current enemy
		ends = 0
		self.time = 0
		self.freeze_p = False
		self.freeze_e = False
		self.start = False


		# Loads enemy and map.
		enemy = __import__('enemy'+str(enemyn))

		self.tilemap = tmx.load(enemy.tilemap, self.screen.get_size()) # sets map and enemy up
		self.sprite_e = tmx.SpriteLayer()
		start_cell = self.tilemap.layers['triggers'].find('enemy')[0]	
		self.enemy = enemy.Enemy((start_cell.px, start_cell.py), self.sprite_e)
		self.tilemap.layers.append(self.sprite_e)

		# Loads player.
		self.sprite_p = tmx.SpriteLayer()
		start_cell = self.tilemap.layers['triggers'].find('player')[0]
		self.player = Player((start_cell.px, start_cell.py), enemyn, self.level, self.sprite_p) 
		self.tilemap.layers.append(self.sprite_p)


		# Game main loop.
		fit = 0

		while 1:
		       
		    # Adjusts frames rate for defining game speed.

                    if self.clock_prec == "medium":  # medium clock precision 
		        if self.speed == 'normal':
		            self.clock.tick_busy_loop(30)
		        elif self.speed == 'fastest':
		            self.clock.tick_busy_loop()

                    else:   # low clock precision
		        if self.speed == 'normal':
		            self.clock.tick(30)
		        elif self.speed == 'fastest':
		            self.clock.tick()


		    # Game timer.          
		    self.time += 1
                    if self.playermode == "human":
		        if self.time >  45: # Delays game start a little bit for human mode.
		            self.start = True
                    else: 
                        self.start = True


		    # Checks screen closing button.
		    self.event = pygame.event.get()	      
		    for event in  self.event:	        
		        if event.type == pygame.QUIT:
		            return
		        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
		            return

		    # Updates objects and draw its itens on screen.
		    self.screen.fill((250,250,250))	
		    self.tilemap.update( 33 / 1000., self)	     
		    self.tilemap.draw(self.screen)

		    # Player life bar.
		    vbar = int(100 *( 1-(self.player.life/float(self.player.max_life)) ))
		    pygame.draw.line(self.screen, (0,   0,   0), [40, 40],[140, 40], 2)
		    pygame.draw.line(self.screen, (0,   0,   0), [40, 45],[140, 45], 5)
		    pygame.draw.line(self.screen, (140,23,23),   [40, 45],[140 - vbar, 45], 5)
		    pygame.draw.line(self.screen, (0,   0,   0), [40, 49],[140, 49], 2)

		    # Enemy life bar.
		    vbar = int(100 *( 1-(self.enemy.life/float(self.enemy.max_life)) ))
		    pygame.draw.line(self.screen, (0,   0,   0), [590, 40],[695, 40], 2)
		    pygame.draw.line(self.screen, (0,   0,   0), [590, 45],[695, 45], 5)
		    pygame.draw.line(self.screen, (184,115,51),  [590, 45],[695 - vbar, 45], 5)
		    pygame.draw.line(self.screen, (0,   0,   0), [590, 49],[695, 49], 2)

		     
		    # Game fitness: the bigger, the best the player is.		       
                    fitness = 0.9*(100 - self.enemy.life) + 0.1*self.player.life - numpy.log(self.time)  
		     		       
		    final_res = round( max(1,self.player.life)/float( max(1,self.enemy.life) ) ,6)


                    def return_run():
                        self.print_logs("RUN: run status: player loses; enemy: "+str(self.enemyn)+"; fitness: " + str(fitness) + "; player life: " + str(self.player.life)  + "; enemy life: " + str(self.enemy.life) + "; time: " + str(self.time))
		        return  fitness, self.player.life, self.enemy.life, self.time 
 

		    # Checks player life status.
		    if self.player.life == 0:            
		        ends -= 1

                        if self.playermode == "human": # tells user that player has lost
		            myfont = pygame.font.SysFont("Comic sams", 100)
		            pygame.font.Font.set_bold
		            self.screen.blit(myfont.render(" Game Over ", 1, (150,24,25)), (150, 180))

		        self.player.kill() # Removes player sprite.
		        self.enemy.kill()  # Removes enemy sprite.

                        if self.playermode == "human":
		            if ends == -20:
                                return return_run()
                        else:
                            return return_run()


		     # Checks enemy life status.
		    if self.enemy.life == 0:
		        ends -= 1

		        self.screen.fill((250,250,250))
		        self.tilemap.draw(self.screen)

                        if self.playermode == "human": # tells user that player has won
		            myfont = pygame.font.SysFont("Comic sams", 100)
		            pygame.font.Font.set_bold
		            self.screen.blit(myfont.render(" You Win ", 1, (194,118,55)), (210, 180))

		        self.enemy.kill()   # Removes enemy sprite.
		        self.player.kill()  # Removes player sprite.

                        if self.playermode == "human":
		            if ends == -20:
                                return return_run()
                        else:
                            return return_run()


                    if self.loadplayer == "no":# removes player sprite from game
                        self.player.kill() 

                    if self.loadenemy == "no":  #removes enemy aprite from game
                        self.enemy.kill() 

		    # Updates screen.
		    pygame.display.flip()


		    # Game runtime limit.
		    if self.playermode == 'ai':
		        if enemyn in (1,2,3,5,7,8):
		            if self.time >= 1000:  
		                return return_run()

		        elif enemyn == 4:
		            if self.time >= 1500: 
		                return return_run()

		        elif enemyn == 6:
		            if self.time >= 2200:  
		                return return_run()

                    else:
                        if self.time >= 3000:  
                            return return_run() 




        def multiple(self): # Repeats run for every enemy in list.

            vfitness, vplayerlife, venemylife, vtime = [],[],[],[]
            for e in self.enemies:

                fitness, playerlife, enemylife, time  = self.run_single(e)
                vfitness.append(fitness) 
                vplayerlife.append(playerlife)  
                venemylife.append(enemylife)  
                vtime.append(time) 
 
            return vfitness, vplayerlife, venemylife, vtime



        def play(self): # checks objective mode.

            if self.multiplemode == "yes":
                return self.multiple()
            else:
                return self.run_single(self.enemies[0])
 
	


 



