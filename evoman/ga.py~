import time
import numpy as np
from math import fabs,sqrt
from game import *

import glob, os

 
ini = time.time()
 
n_vars = 21*5  #simples
dom_u = 1
dom_l = -1
npop = 3

# Reads parameter files. This is the file that must be configured to define experiments settings.
f = open('parameters.txt','r')
parameters = []
for l in f.readlines():        
    parameters.append(l.split(' '))
f.close()
########################## Game parameters. ##########################
enemy  =         int(parameters[0][0]) # Choose from 1 to 8.
level =          int(parameters[1][0]) # Choose from 1 to 3.
playermode  =    str(parameters[2][0]) # Choose between ai and human.
enemymode =      str(parameters[3][0]) # Choose between ai and static. 
speed =          str(parameters[4][0]) # Choose between normal and fastest 
inputs_coded =   str(parameters[5][0]) # Choose between yes or no.
finalsolution =  str(parameters[6][0]) # Choose between yes or no.
randomini =      str(parameters[8][0]) ## Choose between yes or no.
newpop =         str(parameters[9][0]) # Choose between yes for new random population or no for continuing from a saved population. 
gens =           int(parameters[10][0])

#######################################################################

def norm(x,pfit_pop):

    if ( max(pfit_pop) - min(pfit_pop) ) > 0:
        x_norm = ( x - min(pfit_pop) )/( max(pfit_pop) - min(pfit_pop) )
    else:
       x_norm = 0

    if x_norm <= 0:
        x_norm = 0.0000000001
    return x_norm


def simula(x):

    game = Game()  
    game.enemyn = enemy    
    f,p,e,t = game.play(x)  

    return f


def avalia(x):
   return np.array(map(lambda y: simula(y), x))

# no torneio os concorrentes sao selecionados com probabilidade equivalente ao fitness, ou seja, os melhores tem mais chance de conseguir um par para o cruzamento
def torneio(pop):
    c1 =  np.random.randint(0,pop.shape[0], 1)
    c2 =  np.random.randint(0,pop.shape[0], 1)

    if fit_pop[c1] > fit_pop[c2]:
        return pop[c1][0]
    else:
        return pop[c2][0]
   
def limites(x):
    
    if x>dom_u:    
        return dom_u
    elif x<dom_l:
        return dom_l
    else:
        return x 

def cruzamento(pop):

    total_filhos = np.zeros((0,n_vars))

 
    for p in range(0,pop.shape[0], 2):       
        p1 = torneio(pop)
        p2 = torneio(pop)
    
        n_filhos =   np.random.randint(1,3+1, 1) 
        filhos =  np.zeros( (n_filhos, n_vars) )
 
	# todos filhos recebem caracteristicas do pai e da da mae	
  	for f in range(0,n_filhos):	

            cross_prop = np.random.uniform(0,1)
            filhos[f] = p1*cross_prop+p2*(1-cross_prop)

            # mutacao 
            for i in filhos[f]:
                if np.random.uniform(dom_l ,dom_u)<=mutacao:
                    filhos[f][i] =   filhos[f][i]+np.random.normal(dom_l, dom_u)
                    
            filhos[f] = np.array(map(lambda y: limites(y), filhos[f]))           

            total_filhos = np.vstack((total_filhos, filhos[f]))

    return total_filhos


def doomsday(pop,fit_pop):

    # Kills the worst genomes, and replace with new best/random solutions
    worst = int(npop/4)  # a quarter of the population
    order = np.argsort(fit_pop)
    orderasc = order[0:worst]
    	
    for o in orderasc:
        for j in range(0,n_vars):
            pro = numpy.random.uniform(0,1) 
            if np.random.uniform(0,1)  <= pro:	 
                pop[o][j] = np.random.uniform(dom_l,dom_u) # random dna, uniform dist. (diversity factor!=D) 
            else:			
                pop[o][j] = pop[order[-1:]][0][j] # dna from best (Neo ;p)

        fit_pop[o]=avalia([pop[o]])

    return pop,fit_pop

 
#############################################################



if newpop == 'yes':

    pop = np.random.uniform(dom_l, dom_u, (npop, n_vars))
    fit_pop = avalia(pop)

else:

    # Reads population saved in the last iteration ran.
    pop = numpy.loadtxt('lastpop.txt')

    # Reads fitnesses of the last population saved.
    fit_pop = numpy.loadtxt('lastfits.txt')



best = np.argmax(fit_pop)
mutacao = 0.2
 
media = np.mean(fit_pop)
std = np.std(fit_pop)

bold = fit_pop[best]

ini_i = 0 
 
bests = [] 
for file in glob.glob("best_*.txt"):
	if file[0:4]=='best':
		bests.append(int(file.split('.')[0].split('_')[1]))
if len(bests)>0:
	ini_i = max(bests)

file_aux  = open('results.txt','a')
file_aux.write('gen best mean std') 
file_aux.close()

notimproved = 0 
last_best = 0

for i in range(ini_i, gens):

    last_sol = fit_pop[last_best]
    
    filhos = cruzamento(pop) 
    fit_filhos = avalia(filhos)  

    pop = np.vstack((pop,filhos))   
    fit_pop = np.append(fit_pop,fit_filhos)

    best = np.argmax(fit_pop)
    fit_pop[best] = float(avalia(numpy.array([pop[best] ]))[0]) # repetes best eval, for stability issues
    best_sol = fit_pop[best]

    fit_pop_cp = fit_pop
    fit_pop_norm =  np.array(map(lambda y: norm(y,fit_pop_cp), fit_pop)) # avoiding negative probabilities, as fitness is ranges from negative numbers  
 
    probs = (fit_pop_norm)/(fit_pop_norm).sum() 

    escolhidos = np.random.choice(pop.shape[0], npop , p=probs, replace=False)
    escolhidos = np.append(escolhidos[1:],best)
   
    pop = pop[escolhidos]
    fit_pop = fit_pop[escolhidos] 

    if best_sol <= last_sol:
        notimproved += 1
    else:
        notimproved = 0

    last_sol = best_sol

    print 'notimproved',notimproved

    if notimproved >= 15: 
        print 'doomsday'
        file_aux  = open('results.txt','a')
        file_aux.write('\ndoomsday')
        file_aux.close()

        pop, fit_pop = doomsday(pop,fit_pop)
        notimproved = 0  

    best = np.argmax(fit_pop)
    v_std  =  np.std(fit_pop)
    v_mean = np.mean(fit_pop)
 

    file_aux  = open('results.txt','a')

    print '\nIteracao '+str(i),':\n', 'Melhor solucao da populacao...Fitness '+str(round(fit_pop[best],6))+'  e media da geracao '+str(round(v_mean,6))+'  e std da geracao '+str(round(v_std,6))

    file_aux.write('\n'+str(i)+' '+str(round(fit_pop[best],6))+' '+str(round(v_mean,6))+' '+str(round(v_std,6))   )
    file_aux.close()

    # Saves file with best solution ever.
    numpy.savetxt('best_'+str(i)+'.txt',pop[best])

    # Saves files with last pop and its fitnesses.
    numpy.savetxt('lastpop.txt',pop)
    numpy.savetxt('lastfits.txt',fit_pop)


    i +=1 
 


    
fim = time.time() 

print '\nTempo de execucao '+str(round((fim-ini)/60,2))+' minutos \n'

f.close()

file = open('winner_chromosome', 'w')
file.close()



	
